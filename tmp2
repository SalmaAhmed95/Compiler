%{
#include <stdlib.h> /* malloc. */
#include <string.h> /* strlen. */
#include <cstdio>
#include <map>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include "header.h"


using namespace std;
#define TINT  267
#define TFLOAT  268

const string SI_PUSH = "si_push";
const string F_PUSH = "sf_push";
const string I_STORE = "istore";
const string F_STORE = "fstore";
const string I_LOAD = "iload";
const string F_LOAD = "fload"; 
const string ADD = "add";
const string MUL = "mul";
const string DIV = "div";
const string SUB = "sub";
const string NEGATIVE = "iconst_m1";
// stuff from flex that bison needs to know about:
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
 
void yyerror(const char *s);


/*memory location counter for local variables*/
int memory_location_counter = 0;
int temp_counter  = 0;

typedef struct symrec {
  int type;    
  int location;
	
  symrec(int type, int location_counter) {
    this->type = type;
    location = location_counter;
  }

  symrec(){}

} symrec;

map<string, symrec> symTable;
void writeToFile (char *allCode);
string declareAction(symrec);
char *constAction(int type, int ival, float fval);
string getTempName();
pair<char*, string> *loadID(string name);
pair<char*, string>  *performOperation(symrec op1, symrec op2, char *opera);
string getFloatIntOp(symrec op1, symrec op2);
string generateSignCode (string term ,char* sign);
char *assignAction(char *id, string varName);

%}

%union {
  int  ival;
  double fval;
  char *string;
  pair<char*, char*> *passedValue;
}
%start METHOD_BODY
%token <string> ID
%token ASSIGN
%token OPEN_BRACKET
%token CLOSED_BRACKET
%token OPEN_CURLY
%token CLOSED_CURLY
%token If
%token ELSE
%token While
%token <ival> INT
%token <fval> FLOAT
%token <string> RELOP
%token <string> ADDOP
%token <string> MULOP
%type <ival> PRIMITIVE_TYPE 
%type <string> SIGN DECLARATION ASSIGNMENT STATEMENT STATEMENT_LIST METHOD_BODY NUM
%type <passedValue> EXPRESSION SIMPLE_EXPRESSION FACTOR TERM


%%

METHOD_BODY:		STATEMENT_LIST {$$ = $1;
				        writeToFile($$);}
STATEMENT_LIST:		STATEMENT {$$ = $1;}
			| STATEMENT_LIST STATEMENT 
STATEMENT:		DECLARATION {$$ = $1;}
			| IF
			| WHILE
			| ASSIGNMENT {$$ = $1;}
DECLARATION:		PRIMITIVE_TYPE ID ';' {
						memory_location_counter++;
						string varName($2);
						symrec newRec = symrec($1,memory_location_counter);
						symTable[varName] = newRec;
						string tmp = declareAction(newRec);
                                                char *value = (char *)malloc (tmp.length() + 1);
                                                copy( tmp.begin(), tmp.end(), value );
						$$ = value;
					      }
PRIMITIVE_TYPE:		INT {$$ = $1;}
			| FLOAT {$$ = $1;}

IF:			If OPEN_BRACKET EXPRESSION CLOSED_BRACKET OPEN_CURLY STATEMENT CLOSED_CURLY ELSE OPEN_CURLY STATEMENT CLOSED_CURLY

WHILE:			While OPEN_BRACKET EXPRESSION CLOSED_BRACKET OPEN_CURLY STATEMENT CLOSED_CURLY

ASSIGNMENT:		ID ASSIGN EXPRESSION ';' {
                                                     string expCode($3);
						     string assignCode( assignAction($1, $3->second));
						     expCode += assignCode;
						     char *value = (char *)malloc (expCode.length() + 1);
                                                     copy( expCode.begin(), expCode.end(), value );
						     $$ = value;
                                                 } 

EXPRESSION:		SIMPLE_EXPRESSION {$$->first = $1->first; 
                               		  $$->second = $1->second;
					  }
			| SIMPLE_EXPRESSION RELOP SIMPLE_EXPRESSION 

SIMPLE_EXPRESSION:	TERM {
			       $$->first = $1->first; 
                               $$->second = $1->second;
                             }
			| SIGN TERM {
				     string termCode($2->first);
                                     termCode += generateSignCode($2->second,$1);
                                     char *value = (char *)malloc (termCode.length() + 1);
                                     copy( termCode.begin(), termCode.end(), value );
                                     $$->first = value; 
                                     $$->second = $2->second; 
				    }
			| SIMPLE_EXPRESSION ADDOP TERM 

TERM:			FACTOR {
			$$->first = $1->first;
			$$->second = $1->second; }
			| TERM MULOP FACTOR {
					     string termCode($1->first);
					     string factorCode ($3->first);
					     string genCode = termCode + factorCode;
                                             pair<char*, char*> *returnedAttr = performOperation($1->second, $3->second, $2);
					     string attrStr(returnedAttr->first);
					     genCode += attrStr;
                                             char *value = (char *)malloc (genCode.length() + 1);
                                             copy( genCode.begin(), genCode.end(), value );
                                             value[genCode.length()] = 0;
                                             $$->first = value;
					     $$->second = returnedAttr->second;       
                                           }

FACTOR:			ID  {
			string idName($1);
			pair<char*, char*> *attr = loadID(idName);
			$$->first = attr->first;
			$$->second = attr->second;}
			| NUM {$$->first = $1;  $$->second= "";}
			| OPEN_BRACKET EXPRESSION CLOSED_BRACKET {$$->first = $2->first;  
							          $$->second = $2->second;}

SIGN:			ADDOP {$$ = $1;}

NUM:                    INT { $$ = constAction(TINT, $1,0);}
                        | FLOAT {$$ = constAction(TFLOAT,0, $1);}

%%

int main (int argc, char const* argv[]) {
    FILE *fh;
    if (argc == 2 && (fh = fopen(argv[1], "r"))){
          if (!fh) {
		printf("I can't open file!\n");
		return -1;
	  }
          yyin = fh;	
	  // parse through the input until there is no more:
          do {
	  	yyparse();
          } while (!feof(yyin));
    }
	
    for (map<string, symrec>::iterator it = symTable.begin(); it != symTable.end(); it++) {
	cout << (*it).first << "\t" << (*it).second.type << endl;
    }

    return 0;
}

string declareAction(symrec rec) {
	string code;
	if (rec.type == TINT) {
		code += "iconst_0\n";
		code += I_STORE + (memory_location_counter < 4 ? "_" : "") + to_string(memory_location_counter);
	} else if (rec.type == TFLOAT) {
		code += string("fconst_0\n");
		code += F_STORE + (memory_location_counter < 4 ? string("_") : string(" ")) + to_string(memory_location_counter);
	}
	return code;    
}

string assignAction() {



}

char *constAction(int type, int ival, float fval){
                        string val;
                        if (type == TINT){
                         key = to_string(ival);
			 val = SI_PUSH + ' ' + to_string(ival);	
                        } else {
                          key = to_string(fval);
                         val = F_PUSH + ' ' + to_string(fval);
                        }
			val += '\n'; 		
                        char *value = (char *)malloc (val.length() + 1);
			copy(val.begin(), val.end(), value);
                        return value;

}
void yyerror(const char *s) {
	printf("EEK, parse error! %s\n",s);
	// might as well halt now:
	exit(-1);
}

void writeToFile (char *allCode) {
     ofstream myfile;
     myfile.open ("output.txt");
     myfile << allCode;
     myfile.close();

}

string getTempName() {
	string t = "t" + to_string(temp_counter);
	temp_counter++;
        return t;
}

pair<char *, char*> *loadID(string name){
	symrec returnRec = symTable[name];
	string genCode; 
	if (returnRec == NULL) {
		exit(-1);
	}
        string tempName =  getTempName();
	memory_location_counter++;
	symrec temp(returnRec.type, memory_location_counter);
	symTable[temp] = temp; 
       if (returnRec.type == TINT) {
		genCode = I_LOAD + ' ' + to_string(returnRec.location) + '\n' + I_STORE + ' ' + to_string(memory_location_counter) + '\n';

	}else {
	       genCode = F_LOAD +  ' ' + to_string(returnRec.location) + '\n' + F_STORE + ' ' + to_string(memory_location_counter) + '\n';
	}
     
       char *value = (char *)malloc (genCode.length() + 1);
        copy(genCode.begin(), genCode.end(), value);
	char *t = (char *)malloc (genCode.length() + 1);
	copy(tempName.begin(), tempName.end(), value);
	return new pair<char*, char*>(value, t);
}

string getFloatIntOp(symrec op1, symrec op2, string operation1, string operation2, string n1, string n2) {
	string genCode;
	if(n1 != "") genCode = operation1 + ' ' + to_string(op1.location) + "\n", memory_location_counter--, temp_counter--, symTable[n1] = NULL;
	if(n2 != "") genCode += operation2 + ' ' + to_string(op2.location) + "\n", memory_location_counter--, temp_counter--, symTable[n2] = NULL;
	genCode += "f";
	return genCode;
}

pair<char*, char*> *performOperation(string n1, string n2, char *operator) {
	symrec op1 = symTable[n1];
	symrec op2 = symTable[n2];
	string genCode;	
	int type;
	if(op1.type == TFLOAT || op2.type == TFLOAT) {
		if(op1.type == TFLOAT && op2.type == TINT) {
			genCode = getFloatIntOp(op1, op2, F_LOAD, I_LOAD, n1, n2);
		} else if(op1.type == TINT && op2.type == TFLOAT) {
			genCode = getFloatIntOp(op1, op2, I_LOAD, F_LOAD, n1, n2);
		} else {
			genCode = getFloatIntOp(op1, op2, F_LOAD, F_LOAD, n1, n2);
		}
		type = TFLOAT;
	} else {
		if(n1 != "")
			genCode = I_LOAD + ' ' + to_string(op1.location) + '\n', memory_location_counter--, temp_counter--, symTable[n1] = NULL;
		if(n2 != "")
			genCode = I_LOAD + ' ' + to_string(op2.location) + '\n', memory_location_counter--, temp_counter--, symTable[n2] = NULL;
		genCode += "i";
		type = TINT;
	}
	switch(*operator) {
		case '+' : 
			genCode += ADD;
			break;
		case '-' :
			genCode += SUB;
			break;
		case '*' : 
			genCode += MUL;
			break;
		case '/' :
			genCode += DIV;
			break;
		default :
			break;
	}
	genCode += '\n';
	string tempName = getTempName();
	memory_location_counter++;
	symrec tempRec(type, memory_location_counter);
	symTable[tempName] = tempRec;
	if(type == TINT) {
		genCode += I_STORE;	
	} else {
		genCode += F_STORE;	
	}
        char *value = (char *)malloc (genCode.length() + 1);
        copy(genCode.begin(), genCode.end(), value);
	char *t = (char *)malloc (genCode.length() + 1);
	copy(tempName.begin(), tempName.end(), value);
	return new pair<char*, char*>(value, t);
}
string generateSignCode(string term,char* sign){
 string genCode="";
 if(*sign == "+")
    return genCode;
 symrec temp = symTable[term];
 string mul;
 string store;
 if(temp.type == TINT){
  genCode+=I_LOAD;
  mul="i"+ MUL;
  store =I_STORE;
 }else{
  genCode+=F_LOAD;
  mul = "f"+MUL;
  store=F_STORE;
 }
 genCode+=" " +to_string(temp.location)+"\n";
 genCode+=NEGATIVE+"\n";
 genCode+=mul+"\n";
 genCode+=store+" "+to_string(temp.location)+"\n";
 return genCode;
}

char *assignAction(char *idName, string varName){
	string id(idName);
        symrec returnedId = symTable[idName];
        string code = "";
         
          if (returnedId.type == TINT) {
                if (varName != "") {
		symrec varRec = symTable[varName];
		code += I_LOAD + ' ' + to_string(varRec.location) + '\n';
		}
   	        code += I_STORE + ' ' + to_string(returnedId.location) + '\n';
	  } else {
	       	if (varName != "") {
		symrec varRec = symTable[varName];
		code += F_LOAD + ' ' + to_string(varRec.location) + '\n';
		}
   	        code += F_STORE + ' ' + to_string(returnedId.location) + '\n';
	  }
	char *value = (char *)malloc (code.length() + 1);
        copy(code.begin(), code.end(), value);
	return value;
	
}
	

